package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
)

var types []string

func main() {

	// check the AST of each file for protobuf type structs
	fnames := []string{"messages.pb.go", "types.pb.go", "exchange.pb.go", "messages-eos.pb.go", "messages-nano.pb.go"}
	t := template.Must(template.New("typeTemplate").Parse(typeTemplate))
	for _, fn := range fnames {
		parseFile(fn)
	}

	// Write out a new type registry file
	f, err := os.Create("typeRegistry.go")
	if err != nil {
		log.Fatal(err)
	}
	t.Execute(f, types)

}

func parseFile(fname string) {

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, fname, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	// parse the ast for structs
	ast.Inspect(node, findStructTypes)
}

func findStructTypes(n ast.Node) bool {
	ts, ok := n.(*ast.TypeSpec)
	if ok {
		_, isStruct := ts.Type.(*ast.StructType)
		if isStruct {
			types = append(types, ts.Name.Name)
		}
	}
	return true
}

var typeTemplate = `
// Code generated by typeRegistryGenerator.go. DO NOT EDIT.

package kkProto

import (
	"reflect"
)

func init() {
{{- range $val := .}}
	typeRegistry["{{$val}}"] = reflect.TypeOf({{$val}}{})
{{- end}}
}

var typeRegistry = make(map[string]reflect.Type)

// TypeRegistry returns the reflect.Type associated with a given string type-name
// The entries registered in the map should be structs implementing proto.Message
func TypeRegistry(t string) (reflect.Type, bool) {
	v, ok := typeRegistry[t]
	return v, ok
}
`
